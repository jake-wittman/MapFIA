# Import libraries
library(doParallel)
library(ggplot2)
library(dplyr)
library(purrr)
library(stringr)
library(car)
library(zoo)
library(agricolae)

# Import all data
fullpath <- list.files(path = "./data/", pattern = "_servosphere.csv", full.names = T) # get full file names
# Uncomment below for a subset of fullpath for development
# fullpath <- fullpath[1:50]
dat_files <- lapply(fullpath, read.csv2) # put all file names in a list for R
trial_num <- fullpath %>% # extract trial numbers with this pipeline
  basename() %>%
  strsplit(split = "_")
trial_num <- unlist(trial_num)[c(T, F, F)] # remove extraneous text
names(dat_files) <- trial_num

trial_record <- read.csv("data/trial_data_record.csv") # import record of trial
names(trial_record) <- c("date", "id", "day_or_night", "hatch_group", "trial_options",
                         "x_axis", "y_axis", "include", "notes")
trial_record[, c("notes", "trial_options", "x_axis", "y_axis")] <- 
  sapply(trial_record[, c("notes", "trial_options", "x_axis", "y_axis")], as.character)
discard <- which(trial_record$include == 0)
keep_id <- as.character(trial_record$id[-discard])
#dat_files <- dat_files[keep_id]

# Clean up files a bit
colnames <- c("stimulus", "dT", "dx", "dy", "enc1", "enc2", "enc3") 
dat_files <- lapply(dat_files, setNames, colnames) #
Changetype <- function(df){
  # Change dx and dy to numeric variables 
  df$dx <- as.numeric(as.character(df$dx))
  df$dy <- as.numeric(as.character(df$dy))
  df
}
dat_files <- lapply(dat_files, Changetype)

# Check time for each stimulus (should be roughly the same)
SumdT <- function(x) {sum(x$dT)/1000/60} # function for use in sapply
sapply(dat_files, FUN = SumdT) #return a vector of times for each trial to confirm they're roughly correct

# Thin files
Thin <- function(dat, n){ # Function to use with thinning the data
  aggregate(dat[, c("dT", "dx", "dy")], list(rep(1:(nrow(dat) %/% n + 1), each = n, len = nrow(dat))), sum)[, -1]
}
dat_files_agg <- lapply(dat_files, Thin, n = 10) # thin the data
dat_files_agg <- lapply(dat_files_agg, cbind, x = NA, y = NA) # add empty columns for calculating x and y coords for path
for (i in 1:length(dat_files_agg)) { # add trial identifier
  dat_files_agg[[i]] <- cbind(dat_files_agg[[i]], id = as.integer(rep(trial_num[i], nrow(dat_files_agg[[i]]))))
}
dat_files_agg <- lapply(dat_files_agg, # Merge the trial_record information with the servosphere data
                        function(x, y) {merge(x, y)},
                y = trial_record)


# Rotate some dx, dy for some trials so I can calculate choice
registerDoParallel(cores = detectCores() - 1)
  # takes a data frame and if the x_axis character comes alphabetically after the y_axis character
  # it rotates dx and dy 90 degrees clockwise so the location of light stimuli is "consistent" within
  # a treatment. Basically, because we controlled for light position, we need to rotate the paths
  # to actually analyze the data
dat_files_agg <- foreach(j = 1:length(dat_files_agg)) %dopar% { 
  temp_dat <- dat_files_agg[[j]]
  if (all(temp_dat$x_axis > temp_dat$y_axis)) {
    x_new <- temp_dat$dy
    y_new <- -1 * (temp_dat$dx)
    temp_dat$dx <- x_new
    temp_dat$dy <- y_new
    temp_dat$rotated <- 1
  } else {
    temp_dat$rotated <- 0
  }
  temp_dat
}

dat_files <- foreach(j = 1:length(dat_files)) %dopar% { 
  temp_dat <- dat_files_agg[[j]]
  if (all(temp_dat$x_axis > temp_dat$y_axis)) {
    x_new <- temp_dat$dy
    y_new <- -1 * (temp_dat$dx)
    temp_dat$dx <- x_new
    temp_dat$dy <- y_new
    temp_dat$rotated <- 1
  } else {
    temp_dat$rotated <- 0
  }
  temp_dat
}

# Calculate (x, y) coords.

# Single core method
# for (j in 1:length(dat_files_agg)) {
#   for (i in 1:nrow(dat_files_agg[[j]])) {
#     if (i == 1){
#       dat_files_agg[[j]]$x[i] <- 0
#       dat_files_agg[[j]]$y[i] <- 0
#     } else {
#       dat_files_agg[[j]]$x[i] <- dat_files_agg[[j]]$x[i-1] + dat_files_agg[[j]]$dx[i]
#       dat_files_agg[[j]]$y[i] <- dat_files_agg[[j]]$y[i-1] + dat_files_agg[[j]]$dy[i]
#     }
#   }
# }

# Parallel method
registerDoParallel(cores = detectCores() - 1)
# Send each data frame to a different core for processing in foreach loop.
dat_files_agg <- foreach(j = 1:length(dat_files_agg)) %dopar% { 
  temp_dat <- dat_files_agg[[j]]
  for (i in 1:nrow(temp_dat)) {
    if (i == 1){
      temp_dat$x[i] <- 0 # set start position as (0,0)
      temp_dat$y[i] <- 0
    } else {
      temp_dat$x[i] <- temp_dat$x[i-1] + temp_dat$dx[i] # calculate new (x,y) 
      temp_dat$y[i] <- temp_dat$y[i-1] + temp_dat$dy[i]
    }
  }
  temp_dat # call temp_dat to get output
}
names(dat_files_agg) <- trial_num

# Plot paths for each trial
# Set theme for plotting function
simple_theme <- theme(panel.background=element_rect(fill=NA), 
                      panel.border = element_rect(colour = "black",
                                                  fill=NA, size=1),
                      axis.text = element_text(size=12, colour="black"),
                      axis.title=element_text(size=14),
                      legend.text=element_text(size=12),
                      legend.title=element_text(size=14))
PlotPath <- function(df){ 
  # takes a servosphere data file and plots the path
  # title is a vector of titles to put on the plot to help identify the plot
  if (df$include[1] == 1){
  plot <- ggplot(dat = df, aes(x = x, y = y))
  plot + geom_point() + ggtitle(paste(df$id[1]))
  }
}

plotlist <- lapply(dat_files_agg, PlotPath) # create plots
names(plotlist) <- trial_num
# Calculate total distance
TotalDistance <- function(df){ 
  # calculate total distance moved for each data frame (1 trial)
  td <- sum(sqrt((df$dx ^ 2) + (df$dy ^ 2)))
  return(c(df$id[1], td))
}


tot_dist <- sapply(dat_files_agg, TotalDistance) # return total distance moved for each data frame
summary_df <- as.data.frame(x = t(tot_dist)) # start putting together a summary data frame
names(summary_df) <- c("id", "tot_dist") # rename columns


# Calculate displacement and tortuosity
summary_df$displacement <- sapply(dat_files_agg, function(x){sqrt(x$x[nrow(x)] ^ 2 + x$y[nrow(x)] ^ 2)})
summary_df$tortuosity <- summary_df$displacement / summary_df$tot_dist
summary_df <- merge(summary_df, trial_record) #add in the trial record information


# To determine if an insect made a choice, use the proportion of displacement directions in the x or y axis
# direction. Because I've rotated everything, the x-axis and y-axis variables are no longer true in the
# sense if the insect moved in the x direction, it was moving towards the light on the x-axis. Rather
# the actual dx, dy, x, and y have been rotated so the light choice that comes first in the pairing 
# alphabetically is on the x-axis (virtually). I'll need to make sure the trial_options are entered
# alphabetically. So if we find a larva moving mostly in the x-axis direction, it will be moving towards
# the alphabetically first option. Vice versa, if a larva moves in the y-axis direction ,it will be moving
# towards the alphabetically second option.

# Calculate bearing
dat_files_agg <- lapply(dat_files_agg, cbind, ang = NA, ta = NA, turn_velocity = NA, choice = NA)
registerDoParallel(cores = detectCores() - 1)
dat_files_agg <- foreach(j = 1:length(dat_files_agg)) %dopar% {
  temp_dat <- dat_files_agg[[j]]
  for (i in 1:nrow(temp_dat)) {
    
    if (i == 1) {
      temp_dat$ang[i] <- atan2(temp_dat$x[i], temp_dat$y[i])
      temp_dat$turn_velocity[i] <- NA
    } else {
      temp_dat$ang[i] <- atan2(temp_dat$x[i] - temp_dat$x[i-1], temp_dat$y[i] - temp_dat$y[i-1])
    # calculate bearing in radians
    }
  
    if (temp_dat$ang[i] >= 0) {
      temp_dat$bearing[i] <- temp_dat$ang[i] * (180/pi) # converts radians to degrees
    } else {
      temp_dat$bearing[i] <- (temp_dat$ang[i] + 2*pi) * (180/pi) 
    # converts negative radians to positive and then to degrees
    }
  
  if (i > 1) {
    temp_dat$ta[i] <- (temp_dat$bearing[i] - temp_dat$bearing[i-1]) *(pi/180) #calculate turn angle and convert to radians
    if (temp_dat$ta[i] < -pi) {
      temp_dat$ta[i] <- (temp_dat$ta[i] + (2*pi)) * (180/pi)
      } else if (temp_dat$ta[i] > pi) {
        temp_dat$ta[i] <- (temp_dat$ta[i] - (2*pi)) * (180/pi)
      }else {
        temp_dat$ta[i] <- temp_dat$ta[i] * (180/pi)
      }
    }
  }
  temp_dat$bearing <- ifelse(temp_dat$dx != 0 | temp_dat$dy != 0, temp_dat$bearing, NA)
  temp_dat
}

# Circular mean function to get mean and concentration
RollCMean <- function(x){
 m <- suppressWarnings(circular::mean.circular(circular::as.circular(x,
                                                type = "angles",
                                                units = "degrees",
                                                zero = pi/2,
                                                rotation = "clock"),
                        na.rm = T)[[1]])
  
  if (m < 0 & !is.na(m)) { # change negative angles to positive
    m <- 360 + m
  }
  return(m)
}

# Apply the Cmean function as a rolling mean to reduce noise
# By using a rolling mean on the bearings, I reduce noise
# created by wobbles in the insect movement. Currently using
# a 3 second window (width = 3).
Rollbear <- function(y){
  bear <- y$bearing
  res <- rollapply(bear, width = 5, FUN = RollCMean, fill = NA, by = 5)
  y$roll_bear <- res
  return(y)
}

dat_files_agg <- lapply(dat_files_agg, Rollbear)
beep(6)

# Choice calculation
dat_files_agg <- foreach(j = 1:length(dat_files_agg)) %dopar% {
  # Based on bearing, are insects moving in x or y direction
  temp_dat <- dat_files_agg[[j]]
  temp_dat$choice <- ifelse(temp_dat$roll_bear <= 37.5,
                            "y",
                            ifelse(
                              temp_dat$roll_bear <= 52.5,
                              "edge",
                              ifelse(
                                temp_dat$roll_bear <= 127.5,
                                "x",
                                ifelse(
                                  temp_dat$roll_bear <= 142.5,
                                  "edge",
                                  ifelse(
                                    temp_dat$roll_bear <= 217.5,
                                    "y",
                                    ifelse(
                                      temp_dat$roll_bear <= 232.5,
                                      "edge",
                                      ifelse(
                                        temp_dat$roll_bear <= 297.5,
                                        "x",
                                        ifelse(
                                          temp_dat$roll_bear <= 312.5,
                                          "edge",
                                          ifelse(temp_dat$roll_bear <= 360, "y", NA)
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            ))
  temp_dat
}

CMean <- function(x){
  b <- x$bearing
  m <- suppressWarnings(circular::mean.circular(circular::as.circular(b,
                                                                      type = "angles",
                                                                      units = "degrees",
                                                                      zero = pi/2,
                                                                      rotation = "clock"),
                                                na.rm = T)[[1]])
  r <- suppressWarnings(circular::rho.circular(circular::as.circular(b,
                                                                      type = "angles",
                                                                      units = "degrees",
                                                                      zero = pi/2,
                                                                      rotation = "clock"),
                                                na.rm = T)[[1]])
  if (m < 0 & !is.na(m)) { # change negative angles to positive
    m <- 360 + m
  }
  return(c(m, r))
}

avg_bearing <- sapply(dat_files_agg, CMean)
summary_df$avg_bearing <- avg_bearing[1, ]
summary_df$rho <- avg_bearing[2, ]

AssayChoice <- function(x) {
  # Takes a servosphere dataframe and if more than 50% of the "choices" are in the x
  # corridor, prints a 0. If more than 50% are in y, print a 1. If most are in "edge", print 3. If
  # none are > 50, print a 2.
  if (mean(x$choice == "x", na.rm = T) > 0.5) {
    0
  } else if (mean(x$choice == "y", na.rm = T) > 0.5) {
    1
  } else if (mean(x$choice == "edge", na.rm = T) > 0.5) {
    3
  } else {
    NA
  }
}  

summary_df$choice <- sapply(dat_files_agg, AssayChoice) # add larva choice to summary df
summary_df <- summary_df[summary_df$include == 1, ] # Need to remove larvae that went < 10 cm
summary_table <- summary_df %>%
  group_by(trial_options, day_or_night) %>%
  summarize(count = n(), 
            disp = mean(displacement), 
            dist = mean(tot_dist),
            tortuosity = mean(tortuosity),
            bearing = circular::mean.circular(
              circular::as.circular(avg_bearing,
                type = "angles",
                units = "degrees",
                zero = pi /
                  2,
                rotation = "clock"
              )
            ),
            rho = mean(rho),
            binom = sum(choice, na.rm = T)
            )
summary_table$bearing <- ifelse(summary_table$bearing < 0,
                                360 + summary_table$bearing,
                                summary_table$bearing)
summary_table
table(summary_df$choice)

# Boxplots of summary_df variables
ggplot(summary_df, aes(x = day_or_night, y = tot_dist)) +
  geom_boxplot() +
  simple_theme +
  facet_grid(. ~ trial_options)

ggplot(summary_df, aes(x = day_or_night, y = displacement)) +
  geom_boxplot() +
  simple_theme +
  facet_grid(. ~ trial_options)

ggplot(summary_df, aes(x = day_or_night, y = tortuosity)) +
  geom_boxplot() +
  simple_theme +
  facet_grid(. ~ trial_options)

# Histograms of bearing by trial option and day
dtf <- do.call(rbind, dat_files_agg)
opts_list <- split(x = dtf, f = list(dtf$day_or_night, dtf$trial_options))
par(mfrow = c(2, 2))
histlist <- lapply(opts_list, function(x) {hist(x$roll_bear,
                                                plot = T, 
                                                main = c(x$day_or_night[1], x$trial_options[1]),
                                                breaks = 36)})

# Plots of average bearing
ggplot(summary_df, aes(avg_bearing)) +
  geom_histogram(bins = 36) +
  facet_grid(trial_options ~ day_or_night) +
  simple_theme

# rose diagrams
par(mfrow = c(1, 2))
library(circular)
for(i in unique(summary_df$trial_options)) {
  temp_dat <-
    summary_df[summary_df$trial_options == i, ]
  temp_dat$avg_bearing <- as.circular(
    temp_dat$avg_bearing,
    type = "angles",
    units = "degrees",
    zero = pi /
      2,
    rotation = "clock"
  )
  for (j in unique(temp_dat$day_or_night)) {
    
    temp_dat2 <- temp_dat[temp_dat$day_or_night == j,]
    plot(
      temp_dat2$avg_bearing,
      stack = T,
      bin = 72,
      shrink = 1.3
    )
    title(paste(toString(i), toString(j)), line = 0)
    axis.circular(
      at = circular(seq(pi / 4, 7 * pi / 4, pi / 2)),
      zero = pi / 2,
      rotation = "clock",
      cex = 1.1
    ) #add intercardinal direction labels
    rose.diag(
      temp_dat2$avg_bearing,
      bins = 24,
      col = "darkgrey",
      cex = 1.0,
      prop = 1.8,
      add = TRUE
    ) #add rose diagram
  }
}

par(mfrow = c(1, 2))
for(i in unique(summary_df$trial_options)) {
  temp_dat <-
    summary_df[summary_df$trial_options == i,]
  temp_dat$avg_bearing <- as.circular(
    temp_dat$avg_bearing,
    type = "angles",
    units = "degrees",
    zero = pi /
      2,
    rotation = "clock"
  )
  plot(
    temp_dat$avg_bearing,
    stack = T,
    bin = 72,
    shrink = 1.3
  )
  title(paste(toString(i)), line = 0)
  axis.circular(
    at = circular(seq(pi / 4, 7 * pi / 4, pi / 2)),
    zero = pi / 2,
    rotation = "clock",
    cex = 1.1
  ) #add intercardinal direction labels
  rose.diag(
    temp_dat$avg_bearing,
    bins = 24,
    col = "darkgrey",
    cex = 1.0,
    prop = 1.8,
    add = TRUE
  ) #add rose diagram
}

detach(package:circular)
#############################################################################################
# Statistical Analysis
#############################################################################################


# Is the probability of picking a direction influenced
# by the axis the light is on?
summary_df$choice <-
  ifelse(summary_df$choice == 0, 0, ifelse(summary_df$choice == 2, NA, 1))
results_axis <- data.frame()
for (i in unique(summary_df$day_or_night)) {
  temp_dat <- summary_df[summary_df$day_or_night == i, ]
  
  for (j in unique(summary_df$trial_options)) {
    if (i == "N" & j == "dvr" |
        j == "light" |
        j == "yvg") {
      next
    } else {
    # set up temp data set
    temp_dat2 <- temp_dat[temp_dat$trial_options == j, ]
    
    # fit glm model
    fit <- glm(choice ~ x_axis, family = "binomial", data = temp_dat2)
    
    # capture summary
    int <- coef(summary(fit))[[1]]
    slope <- coef(summary(fit))[[2]]
    p <- coef(summary(fit))[[8]]
    AIC <- AIC(fit)
    Deviance <- deviance(fit)
    DFresid <- fit$df.residual
    
    # create temp data frame
    df <- data.frame(d_n = i,
                     opts = j,
                     int = coef(summary(fit))[[1]],
                     slope = coef(summary(fit))[[2]],
                     p = coef(summary(fit))[[8]],
                     AIC = AIC(fit),
                     Deviance = deviance(fit),
                     DFresid = DFresid)
    
    # bind results
    results_axis <- rbind(results_axis, df)
    }
  }
}
results_axis
any(results_axis$p < 0.05)

# Is the probability of making a choice influenced by whether
# or not the insect is in its day or night photoperiod?
results_time <- data.frame()
for (i in unique(summary_df$trial_options)) {
  temp_dat <- summary_df[summary_df$trial_options == i, ]
  # fit glm model
  fit <- glm(choice ~ day_or_night, family = "binomial", data = temp_dat)
  
  # capture summary
  int <- coef(summary(fit))[[1]]
  slope <- coef(summary(fit))[[2]]
  p <- coef(summary(fit))[[8]]
  AIC <- AIC(fit)
  Deviance <- deviance(fit)
  DFresid <- fit$df.residual
  
  # create temp data frame
  df <- data.frame(opts = i,
                   int = coef(summary(fit))[[1]],
                   slope = coef(summary(fit))[[2]],
                   p = coef(summary(fit))[[8]],
                   AIC = AIC(fit),
                   Deviance = deviance(fit),
                   DFresid = DFresid)
  
  # bind results
  results_time <- rbind(results_time, df)
}
results_time
which(results_time$p < 0.05)
# The results of the above test were significant for bvy and light.
# Model suggests that those in the night group were more likely to pick
# yellow light than blue light.

# Another binomial regression...
results_all <- glm(choice ~ trial_options * day_or_night, data = summary_df, family = "binomial")
summary(results_all)
results_all_no_int <- glm(choice ~ trial_options + day_or_night, data = summary_df, family = "binomial")
summary(results_all_no_int)
# These results match what I saw above

# So, I think this means that neither photoperiod nor axis influenced 
# the choices the larvae were making.

# Binomial test - probability of observing N larvae picking the y-axis
# K times, given that our null is 50/50 chance.
binom_test <- pbinom(summary_table$binom, summary_table$count, p = 0.5)
summary_table$binom_results <- sapply(binom_test, function(x)
{
  if (x > 0.5) {
    1 - x
  } else {
    x
  }
}, simplify = T)
summary_table

lm_totdist <- lm(tot_dist ~ day_or_night + trial_options, data = summary_df)
lm_disp <- lm(displacement ~ day_or_night + trial_options, data = summary_df)
lm_tort <- lm(tortuosity ~ day_or_night + trial_options, data = summary_df)


lm_totdist <- lm(tot_dist ~ trial_options, data = summary_df)
lm_disp <- lm(displacement ~ trial_options, data = summary_df)
lm_tort <- lm(tortuosity ~ trial_options, data = summary_df)

Anova(lm_totdist)
Anova(lm_disp)
Anova(lm_tort)

par(mfrow = c(2, 2))
plot(lm_totdist)
plot(lm_disp)
plot(lm_tort)
